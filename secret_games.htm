<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>MiniCatsCraft 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #fps {
      position: absolute; top: 10px; right: 10px; color: white;
      font-family: monospace; background: rgba(0,0,0,0.5); padding: 6px;
      border-radius: 4px;
    }
    #inventory {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 10px;
    }
    .blockBtn {
      width: 40px; height: 40px; border: 2px solid #fff; cursor: pointer;
      background-size: cover; background-position: center;
    }
    .selected {
      border-color: yellow;
    }
  </style>
</head>
<body>
  <div id="fps">FPS: --</div>
  <div id="inventory">
    <div class="blockBtn selected" data-type="grass" style="background-color:#228B22;"></div>
    <div class="blockBtn" data-type="dirt" style="background-color:#8B4513;"></div>
    <div class="blockBtn" data-type="stone" style="background-color:#aaa;"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);

    const materials = {
      grass: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
      dirt: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
      stone: new THREE.MeshLambertMaterial({ color: 0xaaa })
    };

    // Monde de base
    const blocks = [];
    for (let x = 0; x < 16; x++) {
      for (let z = 0; z < 16; z++) {
        const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materials.grass);
        cube.position.set(x, 0, z);
        cube.userData.isBlock = true;
        scene.add(cube);
        blocks.push(cube);
      }
    }

    // Contrôle inventaire
    let selectedType = "grass";
    document.querySelectorAll(".blockBtn").forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll(".blockBtn").forEach(b => b.classList.remove("selected"));
        btn.classList.add("selected");
        selectedType = btn.dataset.type;
      };
    });

    // FPS Display
    const fpsCounter = document.getElementById("fps");
    let last = performance.now();
    function updateFPS() {
      const now = performance.now();
      const fps = Math.round(1000 / (now - last));
      last = now;
      fpsCounter.textContent = `FPS: ${fps}`;
    }

    // Mouse pointerlock
    renderer.domElement.addEventListener("click", () => {
      renderer.domElement.requestPointerLock();
    });

    let rotation = { x: 0, y: 0 };
    document.addEventListener("mousemove", e => {
      if (document.pointerLockElement) {
        rotation.y -= e.movementX * 0.002;
        rotation.x -= e.movementY * 0.002;
        rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
        camera.rotation.set(rotation.x, rotation.y, 0);
      }
    });

    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    // Raycaster
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Clic gauche → poser bloc
    document.addEventListener("mousedown", e => {
      if (e.button === 0) {
        raycaster.setFromCamera({ x: 0, y: 0 }, camera);
        const intersects = raycaster.intersectObjects(blocks);
        if (intersects.length > 0) {
          const hit = intersects[0].object;
          const pos = hit.position.clone().add(intersects[0].face.normal);
          const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materials[selectedType]);
          cube.position.copy(pos.round());
          cube.userData.isBlock = true;
          scene.add(cube);
          blocks.push(cube);
        }
      }
    });

    // Clic droit → retirer bloc
    document.addEventListener("contextmenu", e => {
      e.preventDefault();
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const intersects = raycaster.intersectObjects(blocks);
      if (intersects.length > 0) {
        const hit = intersects[0].object;
        scene.remove(hit);
        blocks.splice(blocks.indexOf(hit), 1);
      }
    });

    function animate() {
      requestAnimationFrame(animate);

      // Mouvement ZQSD
      const speed = 0.1;
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
      if (keys["z"]) camera.position.add(dir.clone().multiplyScalar(speed));
      if (keys["s"]) camera.position.add(dir.clone().multiplyScalar(-speed));
      if (keys["q"]) camera.position.add(right.clone().multiplyScalar(-speed));
      if (keys["d"]) camera.position.add(right.clone().multiplyScalar(speed));

      updateFPS();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
